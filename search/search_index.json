{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"0 Welcome to SIGEL We develop the S patially I nformed G ene E mbedding L earning ( SIGEL ) that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SIGEL first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM. 0.1 Introduction The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SIGEL , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above, SIGEL generates semantically meaningful gene Representations (SGRs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGRs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGR-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGRs for downstream tasks. 1 Preparation 1.1 Installation To use SIGEL, please download code from https://github.com/WLatSunLab/SIGEL or conduct code below: git clone https://github.com/WLatSunLab/SIGEL.git cd SIGEL/ python3 setup.py install 1.2 Getting Help For inquiries related to SIGEL's codebase or experimental setup, please feel free to post your questions in the GitHub issues section of the SIGEL repository . 1.3 Datasets You can access a variety of datasets for spatial gene expression analysis: The Slide-seqV2 dataset of Mouse Hippocampus ( ssq-mHippo ) The 10x-Visium datasets of Human Dorsolateral Prefrontal Cortex ( 10x-hDLPFC ) The 10x-Visium dataset of Human Breast Cancer ( 10x-hBC ) The 10x-Visium datasets of Human Middle Temporal Gyrus ( 10x-hMTG ) The 10x-Visium dataset of Mouse Embryo ( 10x-mEmb ) The SeqFISH dataset of Mouse Embryo ( sqf-mEmb ) Example data required for SIGEL is available here . Please ensure that these data are properly organized as followes: . <SIGEL> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ... 2 Obtain SGRs In this task, we use 10x-hDLPFC-151676 dataset to generate SGRs. 2.1 Data preprocessing We follow standard preprocessing for ST data using SCANPY, removing mitochondrial and ERCC spike-in genes initially. Genes present in fewer than 10 spots are excluded. Quality control is not applied to spatial spots to maintain data integrity. Gene expression counts are normalized by library size and log-transformed. Afterward, spatial coordinates from ST data are converted into images based on quality control outcomes. from src.SIGEL.SIGEL import SIGEL import warnings warnings.filterwarnings(\"ignore\") adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values 2.2 Display gene images Display the visual effects of 8 genes converted into images using the plt.imshow() function. import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 3,figsize=(15, 10), dpi=100) for i in range(2): for j in range(3): axs[i, j].imshow(dataset[12+i+j]) axs[i, j].set_title(f'{gene_name[12+i+j]}') plt.tight_layout() plt.show() 2.3 Getting SGRs labels, SGRs, model = SIGEL.train(dataset, pretrain=True) use cuda: True Pretrain: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [02:56<00:00, 5.87s/it] model saved to model_pretrained/SIGEL.pkl. load pretrained mae from model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:24<00:00, 14.81s/it] torch.Size([16060, 32]) 2.4 Gene co-expression information The effects of clustering as an auxiliary task will be demonstrated, and it will be evaluated whether SGRs can capture gene co-expression information. import squidpy as sq adata.var['cluster_id']=labels name = list(adata.var_names[adata.var['cluster_id']==1]) sq.pl.spatial_scatter(adata, color=name[:8]) 3 Imputing missing genes in FISH-based ST to enhance transcriptomic coverage In this section, We introduce SIGEL-enhanced-transcriptomics-coverage (SIGEL-ETC), a novel SGR-based Generative Adversarial Network (GAN) model. It assumes gene relational semantics are consistent across ST data for the same tissue, allowing it to extrapolate spatial profiles from covered to uncovered genes using comprehensive datasets like 10x Visium. Its effectiveness is demonstrated by reproducing spatial gene profiles from a mouse embryo SeqFISH dataset ( sqf-mEmb ), guided by SGRs from a 10x Visium dataset ( 10x-mEmb ). 3.1 Load 10x-/sqf-mEmb We begin by loading and visualizing SeqFISH and 10x Visium data from mice embryos that share similar health statuses and developmental stages. from src.SIGEL_ETC.src.SIGEL_ETC import SIGEL_ETC adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') adata refers to the sqf-mEmb dataset. key_m represents the gene names in the sqf-mEmb dataset. dataset_m denotes the imagified version of the sqf-mEmb dataset. key_v is the gene name in the 10x-mEmb dataset. dataset_v refers to the imagified 10x-mEmb dataset. 3.2 Display gene images import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 4,figsize=(15, 10), dpi=100) for i in range(2): for j in range(4): axs[i, j].imshow(dataset_m[12+i+j]) axs[i, j].set_title(f'{key_m[12+i+j]}') plt.tight_layout() plt.show() import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 4,figsize=(15, 10), dpi=100) for i in range(2): for j in range(4): axs[i, j].imshow(dataset_v[12+i+j]) axs[i, j].set_title(f'{key_v[12+i+j]}') plt.tight_layout() plt.show() 3.3 Train SIGEL We train SIGEL using all genes from the 10x-mEmb dataset. _, model = SIGEL_ETC.train(dataset_v, pretrain=True) model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) use cuda: True Pretraining: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [01:11<00:00, 2.37s/it] model saved to model_pretrained/SIGEL_ETC.pkl. load pretrained mae from model_pretrained/SIGEL_ETC.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:03<00:00, 12.32s/it] model : Refers to the SIGEL model that has been trained using the imagified data from the 10x-mEmb dataset. all_gamt_v2m : A dictionary mapping gene names to sqf-mEmb image pairs, derived from intersecting genes between the sqf-mEmb and 10x-mEmb datasets. all_gamt_m2v : A dictionary mapping gene names to 10x-mEmb image pairs, also derived from intersecting genes between the sqf-mEmb and 10x-mEmb datasets. 3.4 Train ETC-GAN We use 80% of the intersecting genes between the sqf-mEmb and 10x-mEmb datasets as the training set to train SIGEL-ETC. ETC_GAN, model, SGRs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:52<00:00, 1.91it/s] 3.5 Imputating gene expression We evaluate the SIGEL-ETC on the test set. import matplotlib.pyplot as plt import torch import numpy as np gene_imp = SIGEL_ETC.sqf_gen(ETC_GAN, SGRs, adata) def prepare_and_show_image(ax, tensor_data, title, cmap='Greys', interpolation='nearest'): img = torch.tensor(tensor_data) img = img.squeeze(0).cpu().detach().numpy() ax.imshow(img, cmap=cmap, interpolation=interpolation) ax.set_title(title) ax.axis('off') # Initialize plot fig, axs = plt.subplots(3, 3, figsize=(12, 15), dpi=300) # Data and indices key_m = np.array(list(all_gmat_m2v.keys())) indices = [330, 308, 325] for row, idx in enumerate(indices): # Show real 10x-mEmv prepare_and_show_image(axs[row, 0], all_gmat_v2m[key_m[idx]], key_m[idx]) # Show real sqf-mEmb prepare_and_show_image(axs[row, 1], all_gmat_m2v[key_m[idx]], f'real_{key_m[idx]}') # Show generated sqf-mEmb img_fake = gene_imp[idx] img_real = torch.tensor(all_gmat_m2v[key_m[idx]]).squeeze(0).cpu().detach().numpy() prepare_and_show_image(axs[row, 2], img_fake, f'gen_{key_m[idx]}') plt.show() 3.6 Enhanced spatial clustering import squidpy as sq from src.SIGEL_ETC.src.utils import sequential_gen dataset_m_660, key_m_660 = sequential_gen(model, ETC_GAN, all_gmat_v2m, all_gmat_m2v) Shape of the non-overlapping gene set: (16569, 35, 30) Shape of SGRs: torch.Size([16569, 64]) The first imputation finished, get 110 new genes The second imputation finished, get 220 new genes The third imputation finished, get 330 new genes 3.7 Display ground truth sq.pl.spatial_scatter( adata, color=\"celltype_mapped_refined\", shape=None, figsize=(5, 10), dpi=500, frameon=False, legend_loc=None, save = 'grouns_truth.png', title=None ) 3.8 Display origin leigen result from src.SIGEL_ETC.src.utils import ari_evalution adata = adata[:,list(all_gmat_m2v.keys())] ari_evalution(adata) Iteration 0: Resolution 0.55 -> 20 clusters Iteration 1: Resolution 0.775 -> 22 clusters ARI: 0.3612215326878697 WARNING: Please specify a valid `library_id` or set it permanently in `adata.uns['spatial']` 3.9 Display enhanced leigen result X_imp = np.zeros([adata.X.shape[0], len(dataset_m_660)]) for i in range(X_imp.shape[1]): X_imp[:, i] = dataset_m_660[i][adata.obs['array_y'], adata.obs['array_x']] print(X_imp.shape) import pandas as pd import anndata as ad n_obs = X_imp.shape[1] var_names = key_m_660[:n_obs] var = pd.DataFrame(index=var_names) adata_imp = ad.AnnData(X_imp, obs=adata.obs, var=var, obsm = adata.obsm, uns = adata.uns) ari_evalution(adata_imp) Iteration 0: Resolution 0.55 -> 41 clusters Iteration 1: Resolution 0.325 -> 31 clusters Iteration 2: Resolution 0.21250000000000002 -> 22 clusters ARI: 0.4421413788706413 WARNING: Please specify a valid `library_id` or set it permanently in `adata.uns['spatial']` 4 Spatial variability genes detection 4.1 Load dataset ```bash from src.SIGEL_SVG import simu_zinb from src.SIGEL_SVG import get_svg_score from src.SIGEL.SIGEL import SIGEL import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc import warnings warnings.filterwarnings(\"ignore\") adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values ## 4.2 Train SIGEL ```bash labels, SGRs, model = SIGEL.train(dataset=dataset, pretrain=False) 4.3 Calculate SVGs score svg_score = get_svg_score(SGRs, dataset, adata, model, sim_times=10) ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] 4.4 Display SVGs ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.savefig(\"svg_high_6genes.png\", dpi=100, bbox_inches=\"tight\") plt.show() 4.5 DIsplay non-SVGs ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.savefig(\"svg_low_6genes.png\", dpi=100, bbox_inches=\"tight\") plt.show() Everything else is prepared and ready for deployment. If you have any other needs, please directly contact Wenlin Li at the email: zipging@gmail.com.","title":"SIGEL"},{"location":"#0-welcome-to-sigel","text":"We develop the S patially I nformed G ene E mbedding L earning ( SIGEL ) that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SIGEL first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM.","title":"0 Welcome to SIGEL"},{"location":"#01-introduction","text":"The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SIGEL , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above, SIGEL generates semantically meaningful gene Representations (SGRs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGRs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGR-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGRs for downstream tasks.","title":"0.1 Introduction"},{"location":"#1-preparation","text":"","title":"1 Preparation"},{"location":"#11-installation","text":"To use SIGEL, please download code from https://github.com/WLatSunLab/SIGEL or conduct code below: git clone https://github.com/WLatSunLab/SIGEL.git cd SIGEL/ python3 setup.py install","title":"1.1 Installation"},{"location":"#12-getting-help","text":"For inquiries related to SIGEL's codebase or experimental setup, please feel free to post your questions in the GitHub issues section of the SIGEL repository .","title":"1.2 Getting Help"},{"location":"#13-datasets","text":"You can access a variety of datasets for spatial gene expression analysis: The Slide-seqV2 dataset of Mouse Hippocampus ( ssq-mHippo ) The 10x-Visium datasets of Human Dorsolateral Prefrontal Cortex ( 10x-hDLPFC ) The 10x-Visium dataset of Human Breast Cancer ( 10x-hBC ) The 10x-Visium datasets of Human Middle Temporal Gyrus ( 10x-hMTG ) The 10x-Visium dataset of Mouse Embryo ( 10x-mEmb ) The SeqFISH dataset of Mouse Embryo ( sqf-mEmb ) Example data required for SIGEL is available here . Please ensure that these data are properly organized as followes: . <SIGEL> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ...","title":"1.3 Datasets"},{"location":"#2-obtain-sgrs","text":"In this task, we use 10x-hDLPFC-151676 dataset to generate SGRs.","title":"2 Obtain SGRs"},{"location":"#21-data-preprocessing","text":"We follow standard preprocessing for ST data using SCANPY, removing mitochondrial and ERCC spike-in genes initially. Genes present in fewer than 10 spots are excluded. Quality control is not applied to spatial spots to maintain data integrity. Gene expression counts are normalized by library size and log-transformed. Afterward, spatial coordinates from ST data are converted into images based on quality control outcomes. from src.SIGEL.SIGEL import SIGEL import warnings warnings.filterwarnings(\"ignore\") adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values","title":"2.1 Data preprocessing"},{"location":"#22-display-gene-images","text":"Display the visual effects of 8 genes converted into images using the plt.imshow() function. import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 3,figsize=(15, 10), dpi=100) for i in range(2): for j in range(3): axs[i, j].imshow(dataset[12+i+j]) axs[i, j].set_title(f'{gene_name[12+i+j]}') plt.tight_layout() plt.show()","title":"2.2 Display gene images"},{"location":"#23-getting-sgrs","text":"labels, SGRs, model = SIGEL.train(dataset, pretrain=True) use cuda: True Pretrain: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [02:56<00:00, 5.87s/it] model saved to model_pretrained/SIGEL.pkl. load pretrained mae from model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:24<00:00, 14.81s/it] torch.Size([16060, 32])","title":"2.3 Getting SGRs"},{"location":"#24-gene-co-expression-information","text":"The effects of clustering as an auxiliary task will be demonstrated, and it will be evaluated whether SGRs can capture gene co-expression information. import squidpy as sq adata.var['cluster_id']=labels name = list(adata.var_names[adata.var['cluster_id']==1]) sq.pl.spatial_scatter(adata, color=name[:8])","title":"2.4 Gene co-expression information"},{"location":"#3-imputing-missing-genes-in-fish-based-st-to-enhance-transcriptomic-coverage","text":"In this section, We introduce SIGEL-enhanced-transcriptomics-coverage (SIGEL-ETC), a novel SGR-based Generative Adversarial Network (GAN) model. It assumes gene relational semantics are consistent across ST data for the same tissue, allowing it to extrapolate spatial profiles from covered to uncovered genes using comprehensive datasets like 10x Visium. Its effectiveness is demonstrated by reproducing spatial gene profiles from a mouse embryo SeqFISH dataset ( sqf-mEmb ), guided by SGRs from a 10x Visium dataset ( 10x-mEmb ).","title":"3 Imputing missing genes in FISH-based ST to enhance transcriptomic coverage"},{"location":"#31-load-10x-sqf-memb","text":"We begin by loading and visualizing SeqFISH and 10x Visium data from mice embryos that share similar health statuses and developmental stages. from src.SIGEL_ETC.src.SIGEL_ETC import SIGEL_ETC adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') adata refers to the sqf-mEmb dataset. key_m represents the gene names in the sqf-mEmb dataset. dataset_m denotes the imagified version of the sqf-mEmb dataset. key_v is the gene name in the 10x-mEmb dataset. dataset_v refers to the imagified 10x-mEmb dataset.","title":"3.1 Load 10x-/sqf-mEmb"},{"location":"#32-display-gene-images","text":"import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 4,figsize=(15, 10), dpi=100) for i in range(2): for j in range(4): axs[i, j].imshow(dataset_m[12+i+j]) axs[i, j].set_title(f'{key_m[12+i+j]}') plt.tight_layout() plt.show() import matplotlib.pyplot as plt fig, axs = plt.subplots(2, 4,figsize=(15, 10), dpi=100) for i in range(2): for j in range(4): axs[i, j].imshow(dataset_v[12+i+j]) axs[i, j].set_title(f'{key_v[12+i+j]}') plt.tight_layout() plt.show()","title":"3.2 Display gene images"},{"location":"#33-train-sigel","text":"We train SIGEL using all genes from the 10x-mEmb dataset. _, model = SIGEL_ETC.train(dataset_v, pretrain=True) model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) use cuda: True Pretraining: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [01:11<00:00, 2.37s/it] model saved to model_pretrained/SIGEL_ETC.pkl. load pretrained mae from model_pretrained/SIGEL_ETC.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:03<00:00, 12.32s/it] model : Refers to the SIGEL model that has been trained using the imagified data from the 10x-mEmb dataset. all_gamt_v2m : A dictionary mapping gene names to sqf-mEmb image pairs, derived from intersecting genes between the sqf-mEmb and 10x-mEmb datasets. all_gamt_m2v : A dictionary mapping gene names to 10x-mEmb image pairs, also derived from intersecting genes between the sqf-mEmb and 10x-mEmb datasets.","title":"3.3 Train SIGEL"},{"location":"#34-train-etc-gan","text":"We use 80% of the intersecting genes between the sqf-mEmb and 10x-mEmb datasets as the training set to train SIGEL-ETC. ETC_GAN, model, SGRs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:52<00:00, 1.91it/s]","title":"3.4 Train ETC-GAN"},{"location":"#35-imputating-gene-expression","text":"We evaluate the SIGEL-ETC on the test set. import matplotlib.pyplot as plt import torch import numpy as np gene_imp = SIGEL_ETC.sqf_gen(ETC_GAN, SGRs, adata) def prepare_and_show_image(ax, tensor_data, title, cmap='Greys', interpolation='nearest'): img = torch.tensor(tensor_data) img = img.squeeze(0).cpu().detach().numpy() ax.imshow(img, cmap=cmap, interpolation=interpolation) ax.set_title(title) ax.axis('off') # Initialize plot fig, axs = plt.subplots(3, 3, figsize=(12, 15), dpi=300) # Data and indices key_m = np.array(list(all_gmat_m2v.keys())) indices = [330, 308, 325] for row, idx in enumerate(indices): # Show real 10x-mEmv prepare_and_show_image(axs[row, 0], all_gmat_v2m[key_m[idx]], key_m[idx]) # Show real sqf-mEmb prepare_and_show_image(axs[row, 1], all_gmat_m2v[key_m[idx]], f'real_{key_m[idx]}') # Show generated sqf-mEmb img_fake = gene_imp[idx] img_real = torch.tensor(all_gmat_m2v[key_m[idx]]).squeeze(0).cpu().detach().numpy() prepare_and_show_image(axs[row, 2], img_fake, f'gen_{key_m[idx]}') plt.show()","title":"3.5 Imputating gene expression"},{"location":"#36-enhanced-spatial-clustering","text":"import squidpy as sq from src.SIGEL_ETC.src.utils import sequential_gen dataset_m_660, key_m_660 = sequential_gen(model, ETC_GAN, all_gmat_v2m, all_gmat_m2v) Shape of the non-overlapping gene set: (16569, 35, 30) Shape of SGRs: torch.Size([16569, 64]) The first imputation finished, get 110 new genes The second imputation finished, get 220 new genes The third imputation finished, get 330 new genes","title":"3.6 Enhanced spatial clustering"},{"location":"#37-display-ground-truth","text":"sq.pl.spatial_scatter( adata, color=\"celltype_mapped_refined\", shape=None, figsize=(5, 10), dpi=500, frameon=False, legend_loc=None, save = 'grouns_truth.png', title=None )","title":"3.7 Display ground truth"},{"location":"#38-display-origin-leigen-result","text":"from src.SIGEL_ETC.src.utils import ari_evalution adata = adata[:,list(all_gmat_m2v.keys())] ari_evalution(adata) Iteration 0: Resolution 0.55 -> 20 clusters Iteration 1: Resolution 0.775 -> 22 clusters ARI: 0.3612215326878697 WARNING: Please specify a valid `library_id` or set it permanently in `adata.uns['spatial']`","title":"3.8 Display origin leigen result"},{"location":"#39-display-enhanced-leigen-result","text":"X_imp = np.zeros([adata.X.shape[0], len(dataset_m_660)]) for i in range(X_imp.shape[1]): X_imp[:, i] = dataset_m_660[i][adata.obs['array_y'], adata.obs['array_x']] print(X_imp.shape) import pandas as pd import anndata as ad n_obs = X_imp.shape[1] var_names = key_m_660[:n_obs] var = pd.DataFrame(index=var_names) adata_imp = ad.AnnData(X_imp, obs=adata.obs, var=var, obsm = adata.obsm, uns = adata.uns) ari_evalution(adata_imp) Iteration 0: Resolution 0.55 -> 41 clusters Iteration 1: Resolution 0.325 -> 31 clusters Iteration 2: Resolution 0.21250000000000002 -> 22 clusters ARI: 0.4421413788706413 WARNING: Please specify a valid `library_id` or set it permanently in `adata.uns['spatial']`","title":"3.9 Display enhanced leigen result"},{"location":"#4-spatial-variability-genes-detection","text":"","title":"4 Spatial variability genes detection"},{"location":"#41-load-dataset","text":"```bash from src.SIGEL_SVG import simu_zinb from src.SIGEL_SVG import get_svg_score from src.SIGEL.SIGEL import SIGEL import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc import warnings warnings.filterwarnings(\"ignore\") adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values ## 4.2 Train SIGEL ```bash labels, SGRs, model = SIGEL.train(dataset=dataset, pretrain=False)","title":"4.1 Load dataset"},{"location":"#43-calculate-svgs-score","text":"svg_score = get_svg_score(SGRs, dataset, adata, model, sim_times=10) ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1]","title":"4.3 Calculate SVGs score"},{"location":"#44-display-svgs","text":"## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.savefig(\"svg_high_6genes.png\", dpi=100, bbox_inches=\"tight\") plt.show()","title":"4.4 Display SVGs"},{"location":"#45-display-non-svgs","text":"## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.savefig(\"svg_low_6genes.png\", dpi=100, bbox_inches=\"tight\") plt.show() Everything else is prepared and ready for deployment. If you have any other needs, please directly contact Wenlin Li at the email: zipging@gmail.com.","title":"4.5 DIsplay non-SVGs"},{"location":"Preparation/","text":"Preparation Installation Downloading SIGEL code from https://github.com/WLatSunLab/SIGEL git clone https://github.com/WLatSunLab/SIGEL.git Rename SIGEL-main as SIGEL. Download Data You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SIGEL.and make sure these data are organized in the following structure: -SIGEL -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -... Data in spacific task SIGEL-ETC from SIGEL.src.main.SIGEL import SIGEL ## get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) # key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') SIGEL-SVG ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) SIGEL-SC ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"Preparation"},{"location":"Preparation/#preparation","text":"","title":"Preparation"},{"location":"Preparation/#installation","text":"Downloading SIGEL code from https://github.com/WLatSunLab/SIGEL git clone https://github.com/WLatSunLab/SIGEL.git Rename SIGEL-main as SIGEL.","title":"Installation"},{"location":"Preparation/#download-data","text":"You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SIGEL.and make sure these data are organized in the following structure: -SIGEL -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -...","title":"Download Data"},{"location":"Preparation/#data-in-spacific-task","text":"","title":"Data in spacific task"},{"location":"Preparation/#sigel-etc","text":"from SIGEL.src.main.SIGEL import SIGEL ## get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) # key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image')","title":"SIGEL-ETC"},{"location":"Preparation/#sigel-svg","text":"## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"SIGEL-SVG"},{"location":"Preparation/#sigel-sc","text":"## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"SIGEL-SC"},{"location":"SIGEL/","text":"Step1: Load data from SIGEL.src.main.SIGEL import SIGEL from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values Step2: Generate SGEs python ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step3: Hierarchical clustering ## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"SIGEL"},{"location":"SIGEL/#step1-load-data","text":"from SIGEL.src.main.SIGEL import SIGEL from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values","title":"Step1: Load data"},{"location":"SIGEL/#step2-generate-sges","text":"python ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step2: Generate SGEs"},{"location":"SIGEL/#step3-hierarchical-clustering","text":"## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"Step3: Hierarchical clustering"},{"location":"SIGEL_ETC/","text":"Step1: Load 10x-mEmb and sqf-mEmb from SIGEL.src.SIGEL_ETC.src.main.SIGEL_ETC import SIGEL_ETC # get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') Step2: Train the SIGEL-ETC # load pretrained SIGEL model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s] Step3: Generate genes expression image on the test set img_gen = SIGEL_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"SIGEL ETC"},{"location":"SIGEL_ETC/#step1-load-10x-memb-and-sqf-memb","text":"from SIGEL.src.SIGEL_ETC.src.main.SIGEL_ETC import SIGEL_ETC # get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image')","title":"Step1: Load 10x-mEmb and sqf-mEmb"},{"location":"SIGEL_ETC/#step2-train-the-sigel-etc","text":"# load pretrained SIGEL model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s]","title":"Step2: Train the SIGEL-ETC"},{"location":"SIGEL_ETC/#step3-generate-genes-expression-image-on-the-test-set","text":"img_gen = SIGEL_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"Step3: Generate genes expression image on the test set"},{"location":"SIGEL_SC/","text":"SIGEL-SC Step1: Load data from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.SIGEL_SC.SIGEL_SC import SIGEL_SC from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s] Step2: Generate SVG score by SIGEL-SVG ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it] Stpe3: Carry out SIGEL-SC ## get original data adata= SIGEL.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SIGEL_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SIGEL_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only... Stpe4: Show the result ## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"SIGEL-SC"},{"location":"SIGEL_SC/#sigel-sc","text":"","title":"SIGEL-SC"},{"location":"SIGEL_SC/#step1-load-data","text":"from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.SIGEL_SC.SIGEL_SC import SIGEL_SC from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s]","title":"Step1: Load data"},{"location":"SIGEL_SC/#step2-generate-svg-score-by-sigel-svg","text":"## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it]","title":"Step2: Generate SVG score by SIGEL-SVG"},{"location":"SIGEL_SC/#stpe3-carry-out-sigel-sc","text":"## get original data adata= SIGEL.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SIGEL_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SIGEL_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only...","title":"Stpe3: Carry out SIGEL-SC"},{"location":"SIGEL_SC/#stpe4-show-the-result","text":"## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"Stpe4: Show the result"},{"location":"SIGEL_SVG/","text":"Step1: Load data from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step2: Train SIGEL to get SGEs ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it] Step3: Generate SVG score ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it] Step4: Display the result ## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"SIGEL SVG"},{"location":"SIGEL_SVG/#step1-load-data","text":"from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step1: Load data"},{"location":"SIGEL_SVG/#step2-train-sigel-to-get-sges","text":"## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it]","title":"Step2: Train SIGEL to get SGEs"},{"location":"SIGEL_SVG/#step3-generate-svg-score","text":"## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it]","title":"Step3: Generate SVG score"},{"location":"SIGEL_SVG/#step4-display-the-result","text":"## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"Step4: Display the result"}]}