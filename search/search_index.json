{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"0 Welcome to SpaCEX! We develop the SpaCEX which utilize self-supervised learning on SPa tially C o- EX pressed genes that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SpaCEX first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM. 0.1 Introduction The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SpaCEX , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above , SpaCEX generates semantically meaningful gene embeddings (SGEs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGEs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGE-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGEs for downstream tasks. 1 Preparation 1.1 Installation To use SpaCEX, please download code from https://github.com/WLatSunLab/SpaCEX or conduct code below: git clone https://github.com/WLatSunLab/SpaCEX.git 1.2 How to get help for SpaCEX Questions about SpaceX's code or experiments can be asked in the GitHub issue section at https://github.com/WLatSunLab/SpaCEX. 1.3 Example Datasets You can access a variety of datasets for spatial gene expression analysis: Mouse Hippocampus Dataset ( ssq-mHippo ) : Available for detailed study. Human Dorsolateral Prefrontal Cortex Datasets ( 10x-hDLPFC ) : Information and datasets are accessible here. Human Breast Cancer Dataset ( 10x-hBC ) : Obtainable for research purposes. Mouse Embryo Dataset based on 10x Visium ( 10x-mEmb ) : Available for comprehensive genetic analysis. Mouse Embryo Dataset based on SeqFISH ( sqf-mEmb ) : Can be accessed for advanced spatial analysis. Example data required for SpaCEX is available here . Please ensure that these data are properly organized as followes: . <SpaCEX> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ... 1.4 Quikc start in three specific tasks Here, example data is preprocessed to demonstrate the application of SpaCEX in three tasks: Enhancement of the Transcriptomic Coverage in Fish-based ST (ETC) , SVG Detection , and Spatial Clustering . In each task, we first remove mitochondrial and External RNA Controls Consortium (ERCC) spike-in genes. Then, genes detected in fewer than 10 spots are excluded. To preserve the spatial data integrity, we do not perform quality control on spatial spots. Finally, the gene expression counts are normalized by library size, followed by log-transformation. 1.4.1 ETC data process In the data preprocessing step for ETC, it is assumed that the example data is organized as depicted in Section 1.3. Building upon this, one can read the SeqFish data adata and perform data preprocessing to yield processed gene names key_m , gene expression data in image format dataset_m , and gene names for 10x-Visium data key_v , along with image format data dataset_v . from SpaCEX.src.SpaCEX_ETC.src.main.SpaCEX_ETC import SpaCEX_ETC ## get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) # key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image') 1.4.2 SVG detection data process In the SVG detection process, the ST data read into adata undergoes preprocessing and is then transformed into an image-formatted dataset dataset . ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) 1.4.3 Spatial clustering data process During the spatial clustering phase, the ST data, once ingested into adata , is subject to preprocessing steps before being formatted into an image-based dataset, `dataset``. ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) 2 Train model to obtain SpaCEX-Generated Embeddings (SGEs) via ST dataset In this task, we use 10x-visium data adata to generate embeddings SGEs. 2.1 Data preprocessing The original adata is processed and converted into an image dataset dataset , with the gene names also extracted as gene_name from SpaCEX.src.main.SpaCEX import SpaCEX from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) gene_name = adata.var.index.values In this","title":"SpaCEX"},{"location":"#0-welcome-to-spacex","text":"We develop the SpaCEX which utilize self-supervised learning on SPa tially C o- EX pressed genes that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SpaCEX first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM.","title":"0 Welcome to SpaCEX!"},{"location":"#01-introduction","text":"The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SpaCEX , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above , SpaCEX generates semantically meaningful gene embeddings (SGEs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGEs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGE-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGEs for downstream tasks.","title":"0.1 Introduction"},{"location":"#1-preparation","text":"","title":"1 Preparation"},{"location":"#11-installation","text":"To use SpaCEX, please download code from https://github.com/WLatSunLab/SpaCEX or conduct code below: git clone https://github.com/WLatSunLab/SpaCEX.git","title":"1.1 Installation"},{"location":"#12-how-to-get-help-for-spacex","text":"Questions about SpaceX's code or experiments can be asked in the GitHub issue section at https://github.com/WLatSunLab/SpaCEX.","title":"1.2 How to get help for SpaCEX"},{"location":"#13-example-datasets","text":"You can access a variety of datasets for spatial gene expression analysis: Mouse Hippocampus Dataset ( ssq-mHippo ) : Available for detailed study. Human Dorsolateral Prefrontal Cortex Datasets ( 10x-hDLPFC ) : Information and datasets are accessible here. Human Breast Cancer Dataset ( 10x-hBC ) : Obtainable for research purposes. Mouse Embryo Dataset based on 10x Visium ( 10x-mEmb ) : Available for comprehensive genetic analysis. Mouse Embryo Dataset based on SeqFISH ( sqf-mEmb ) : Can be accessed for advanced spatial analysis. Example data required for SpaCEX is available here . Please ensure that these data are properly organized as followes: . <SpaCEX> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ...","title":"1.3 Example Datasets"},{"location":"#14-quikc-start-in-three-specific-tasks","text":"Here, example data is preprocessed to demonstrate the application of SpaCEX in three tasks: Enhancement of the Transcriptomic Coverage in Fish-based ST (ETC) , SVG Detection , and Spatial Clustering . In each task, we first remove mitochondrial and External RNA Controls Consortium (ERCC) spike-in genes. Then, genes detected in fewer than 10 spots are excluded. To preserve the spatial data integrity, we do not perform quality control on spatial spots. Finally, the gene expression counts are normalized by library size, followed by log-transformation.","title":"1.4 Quikc start in three specific tasks"},{"location":"#141-etc-data-process","text":"In the data preprocessing step for ETC, it is assumed that the example data is organized as depicted in Section 1.3. Building upon this, one can read the SeqFish data adata and perform data preprocessing to yield processed gene names key_m , gene expression data in image format dataset_m , and gene names for 10x-Visium data key_v , along with image format data dataset_v . from SpaCEX.src.SpaCEX_ETC.src.main.SpaCEX_ETC import SpaCEX_ETC ## get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) # key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image')","title":"1.4.1 ETC data process"},{"location":"#142-svg-detection-data-process","text":"In the SVG detection process, the ST data read into adata undergoes preprocessing and is then transformed into an image-formatted dataset dataset . ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata)","title":"1.4.2 SVG detection data process"},{"location":"#143-spatial-clustering-data-process","text":"During the spatial clustering phase, the ST data, once ingested into adata , is subject to preprocessing steps before being formatted into an image-based dataset, `dataset``. ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata)","title":"1.4.3 Spatial clustering data process"},{"location":"#2-train-model-to-obtain-spacex-generated-embeddings-sges-via-st-dataset","text":"In this task, we use 10x-visium data adata to generate embeddings SGEs.","title":"2 Train model to obtain SpaCEX-Generated Embeddings (SGEs) via ST dataset"},{"location":"#21-data-preprocessing","text":"The original adata is processed and converted into an image dataset dataset , with the gene names also extracted as gene_name from SpaCEX.src.main.SpaCEX import SpaCEX from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) gene_name = adata.var.index.values In this","title":"2.1 Data preprocessing"},{"location":"Preparation/","text":"Preparation Installation Downloading SpaCEX code from https://github.com/WLatSunLab/SpaCEX git clone https://github.com/WLatSunLab/SpaCEX.git Rename SpaCEX-main as SpaCEX. Download Data You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SpaCEX.and make sure these data are organized in the following structure: -SpaCEX -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -... Data in spacific task SpaCEX-ETC from SpaCEX.src.main.SpaCEX import SpaCEX ## get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) # key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image') SpaCEX-SVG ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) SpaCEX-SC ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata)","title":"Preparation"},{"location":"Preparation/#preparation","text":"","title":"Preparation"},{"location":"Preparation/#installation","text":"Downloading SpaCEX code from https://github.com/WLatSunLab/SpaCEX git clone https://github.com/WLatSunLab/SpaCEX.git Rename SpaCEX-main as SpaCEX.","title":"Installation"},{"location":"Preparation/#download-data","text":"You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SpaCEX.and make sure these data are organized in the following structure: -SpaCEX -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -...","title":"Download Data"},{"location":"Preparation/#data-in-spacific-task","text":"","title":"Data in spacific task"},{"location":"Preparation/#spacex-etc","text":"from SpaCEX.src.main.SpaCEX import SpaCEX ## get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) # key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image')","title":"SpaCEX-ETC"},{"location":"Preparation/#spacex-svg","text":"## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata)","title":"SpaCEX-SVG"},{"location":"Preparation/#spacex-sc","text":"## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata)","title":"SpaCEX-SC"},{"location":"SpaCEX/","text":"Step1: Load data from SpaCEX.src.main.SpaCEX import SpaCEX from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) gene_name = adata.var.index.values Step2: Generate SGEs python ## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step3: Hierarchical clustering ## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"SpaCEX"},{"location":"SpaCEX/#step1-load-data","text":"from SpaCEX.src.main.SpaCEX import SpaCEX from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) gene_name = adata.var.index.values","title":"Step1: Load data"},{"location":"SpaCEX/#step2-generate-sges","text":"python ## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step2: Generate SGEs"},{"location":"SpaCEX/#step3-hierarchical-clustering","text":"## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"Step3: Hierarchical clustering"},{"location":"SpaCEX_ETC/","text":"Step1: Load 10x-mEmb and sqf-mEmb from SpaCEX.src.SpaCEX_ETC.src.main.SpaCEX_ETC import SpaCEX_ETC # get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) #key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image') Step2: Train the SpaCEX-ETC # load pretrained SpaCEX model = SpaCEX_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SpaCEX_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SpaCEX_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s] Step3: Generate genes expression image on the test set img_gen = SpaCEX_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"SpaCEX ETC"},{"location":"SpaCEX_ETC/#step1-load-10x-memb-and-sqf-memb","text":"from SpaCEX.src.SpaCEX_ETC.src.main.SpaCEX_ETC import SpaCEX_ETC # get data on 10x and sqf adata = SpaCEX_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SpaCEX_ETC.data_process(adata) #key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image')","title":"Step1: Load 10x-mEmb and sqf-mEmb"},{"location":"SpaCEX_ETC/#step2-train-the-spacex-etc","text":"# load pretrained SpaCEX model = SpaCEX_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SpaCEX_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SpaCEX_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s]","title":"Step2: Train the SpaCEX-ETC"},{"location":"SpaCEX_ETC/#step3-generate-genes-expression-image-on-the-test-set","text":"img_gen = SpaCEX_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"Step3: Generate genes expression image on the test set"},{"location":"SpaCEX_SC/","text":"SpaCEX-SC Step1: Load data from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SpaCEX.src.SpaCEX_SVG.utils import simu_zinb from SpaCEX.src.SpaCEX_SVG.utils import get_svg_score from SpaCEX.src.SpaCEX_SC.SpaCEX_SC import SpaCEX_SC from SpaCEX.src.main.SpaCEX import SpaCEX import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s] Step2: Generate SVG score by SpaCEX-SVG ## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it] Stpe3: Carry out SpaCEX-SC ## get original data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SpaCEX_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SpaCEX_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only... Stpe4: Show the result ## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"SpaCEX-SC"},{"location":"SpaCEX_SC/#spacex-sc","text":"","title":"SpaCEX-SC"},{"location":"SpaCEX_SC/#step1-load-data","text":"from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SpaCEX.src.SpaCEX_SVG.utils import simu_zinb from SpaCEX.src.SpaCEX_SVG.utils import get_svg_score from SpaCEX.src.SpaCEX_SC.SpaCEX_SC import SpaCEX_SC from SpaCEX.src.main.SpaCEX import SpaCEX import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s]","title":"Step1: Load data"},{"location":"SpaCEX_SC/#step2-generate-svg-score-by-spacex-svg","text":"## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it]","title":"Step2: Generate SVG score by SpaCEX-SVG"},{"location":"SpaCEX_SC/#stpe3-carry-out-spacex-sc","text":"## get original data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SpaCEX_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SpaCEX_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only...","title":"Stpe3: Carry out SpaCEX-SC"},{"location":"SpaCEX_SC/#stpe4-show-the-result","text":"## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"Stpe4: Show the result"},{"location":"SpaCEX_SVG/","text":"Step1: Load data from SpaCEX.src.SpaCEX_SVG.utils import simu_zinb from SpaCEX.src.SpaCEX_SVG.utils import get_svg_score from SpaCEX.src.main.SpaCEX import SpaCEX import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step2: Train SpaCEX to get SGEs ## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it] Step3: Generate SVG score ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it] Step4: Display the result ## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"SpaCEX SVG"},{"location":"SpaCEX_SVG/#step1-load-data","text":"from SpaCEX.src.SpaCEX_SVG.utils import simu_zinb from SpaCEX.src.SpaCEX_SVG.utils import get_svg_score from SpaCEX.src.main.SpaCEX import SpaCEX import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SpaCEX.get_data(sample_id='151676', data_type='adata') dataset, adata = SpaCEX.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step1: Load data"},{"location":"SpaCEX_SVG/#step2-train-spacex-to-get-sges","text":"## train model with pretrained model y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it]","title":"Step2: Train SpaCEX to get SGEs"},{"location":"SpaCEX_SVG/#step3-generate-svg-score","text":"## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it]","title":"Step3: Generate SVG score"},{"location":"SpaCEX_SVG/#step4-display-the-result","text":"## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"Step4: Display the result"}]}