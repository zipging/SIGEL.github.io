{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"0 Welcome to SIGEL We develop the S patially I nformed G ene E mbedding L earning ( SIGEL ) that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SIGEL first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM. 0.1 Introduction The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SIGEL , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above , SIGEL generates semantically meaningful gene Representations (SGRs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGRs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGR-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGRs for downstream tasks. 1 Preparation 1.1 Installation To use SIGEL, please download code from https://github.com/WLatSunLab/SIGEL or conduct code below: git clone https://github.com/WLatSunLab/SIGEL.git 1.2 How to get help for SIGEL Questions about SIGEL's code or experiments can be asked in the GitHub issue section at https://github.com/WLatSunLab/SIGEL. 1.3 Example Datasets You can access a variety of datasets for spatial gene expression analysis: Mouse Hippocampus Dataset ( ssq-mHippo ) : Available for detailed study. Human Dorsolateral Prefrontal Cortex Datasets ( 10x-hDLPFC ) : Information and datasets are accessible here. Human Breast Cancer Dataset ( 10x-hBC ) : Obtainable for research purposes. Mouse Embryo Dataset based on 10x Visium ( 10x-mEmb ) : Available for comprehensive genetic analysis. Mouse Embryo Dataset based on SeqFISH ( sqf-mEmb ) : Can be accessed for advanced spatial analysis. Example data required for SIGEL is available here . Please ensure that these data are properly organized as followes: . <SIGEL> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ... 2 Train model to obtain SIGEL-Generated Embeddings (SGRs) via ST dataset In this task, we use 10x-visium data adata to generate embeddings SGRs. 2.1 Data preprocessing The original adata is processed and converted into an image dataset dataset , with the gene names also extracted as gene_name from SIGEL.src.main.SIGEL import SIGEL import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values ## get SGRs z, model = SIGEL.train(dataset, pretrain=True) **Everything else is prepared and ready for deployment. If you have any other needs, please directly contact Wenlin Li at the email: zipging@gmail.com. **","title":"SIGEL"},{"location":"#0-welcome-to-sigel","text":"We develop the S patially I nformed G ene E mbedding L earning ( SIGEL ) that can simultaneously identify spatially co-expressed genes and learn semantically meaningful gene embeddings from SRT data through a pretext task of gene clustering. SIGEL first employs an image encoder to transform the spatial expression maps of genes into gene embeddings modeled by a Student\u2019s t mixture distribution (SMM). Subsequently, a discriminatively boosted gene clustering algorithm is applied on the posterior soft assignments of genes to the mixture components, iteratively adapting the parameters of the encoder and the SMM.","title":"0 Welcome to SIGEL"},{"location":"#01-introduction","text":"The limited exploration into spatial gene co-expression within tissues has been a significant bottleneck in fully harnessing the spatial genomic context for more insightful gene representations. To bridge this gap, we introduce SIGEL , a novel few-shot, self-supervised learning model tailored for the genomic field. As shown in the figure above , SIGEL generates semantically meaningful gene Representations (SGRs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGRs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGR-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGRs for downstream tasks.","title":"0.1 Introduction"},{"location":"#1-preparation","text":"","title":"1 Preparation"},{"location":"#11-installation","text":"To use SIGEL, please download code from https://github.com/WLatSunLab/SIGEL or conduct code below: git clone https://github.com/WLatSunLab/SIGEL.git","title":"1.1 Installation"},{"location":"#12-how-to-get-help-for-sigel","text":"Questions about SIGEL's code or experiments can be asked in the GitHub issue section at https://github.com/WLatSunLab/SIGEL.","title":"1.2 How to get help for SIGEL"},{"location":"#13-example-datasets","text":"You can access a variety of datasets for spatial gene expression analysis: Mouse Hippocampus Dataset ( ssq-mHippo ) : Available for detailed study. Human Dorsolateral Prefrontal Cortex Datasets ( 10x-hDLPFC ) : Information and datasets are accessible here. Human Breast Cancer Dataset ( 10x-hBC ) : Obtainable for research purposes. Mouse Embryo Dataset based on 10x Visium ( 10x-mEmb ) : Available for comprehensive genetic analysis. Mouse Embryo Dataset based on SeqFISH ( sqf-mEmb ) : Can be accessed for advanced spatial analysis. Example data required for SIGEL is available here . Please ensure that these data are properly organized as followes: . <SIGEL> \u251c\u2500\u2500 ... \u251c\u2500\u2500 <data> \u2502 \u251c\u2500\u2500 151676_10xvisium.h5ad \u2502 \u251c\u2500\u2500 DLPFC_matrix_151676.dat \u2502 \u2514\u2500\u2500 <mEmb> \u2502 \u251c\u2500\u2500 10x_mEmb_matrix.dat \u2502 \u251c\u2500\u2500 sqf_mEmb_adata.h5ad \u2502 \u2514\u2500\u2500 qf_mEmb_matrix.dat \u251c\u2500\u2500 <model_pretrained> \u2502 \u2502 \u2514\u2500\u2500 ...","title":"1.3 Example Datasets"},{"location":"#2-train-model-to-obtain-sigel-generated-embeddings-sgrs-via-st-dataset","text":"In this task, we use 10x-visium data adata to generate embeddings SGRs.","title":"2 Train model to obtain SIGEL-Generated Embeddings (SGRs) via ST dataset"},{"location":"#21-data-preprocessing","text":"The original adata is processed and converted into an image dataset dataset , with the gene names also extracted as gene_name from SIGEL.src.main.SIGEL import SIGEL import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values ## get SGRs z, model = SIGEL.train(dataset, pretrain=True) **Everything else is prepared and ready for deployment. If you have any other needs, please directly contact Wenlin Li at the email: zipging@gmail.com. **","title":"2.1 Data preprocessing"},{"location":"Preparation/","text":"Preparation Installation Downloading SIGEL code from https://github.com/WLatSunLab/SIGEL git clone https://github.com/WLatSunLab/SIGEL.git Rename SIGEL-main as SIGEL. Download Data You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SIGEL.and make sure these data are organized in the following structure: -SIGEL -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -... Data in spacific task SIGEL-ETC from SIGEL.src.main.SIGEL import SIGEL ## get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) # key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') SIGEL-SVG ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) SIGEL-SC ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"Preparation"},{"location":"Preparation/#preparation","text":"","title":"Preparation"},{"location":"Preparation/#installation","text":"Downloading SIGEL code from https://github.com/WLatSunLab/SIGEL git clone https://github.com/WLatSunLab/SIGEL.git Rename SIGEL-main as SIGEL.","title":"Installation"},{"location":"Preparation/#download-data","text":"You can get the mouse hippocampus dataset ssq-mHippo , the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. You can also obtain the example data here required for SIGEL.and make sure these data are organized in the following structure: -SIGEL -data -151676_10xvisium.h5ad -DLPFC_matrix_151676.dat -mEmb -10x_mEmb_matrix.dat -sqf_mEmb_adata.h5ad -sqf_mEmb_matrix.dat -model_pretrained -...","title":"Download Data"},{"location":"Preparation/#data-in-spacific-task","text":"","title":"Data in spacific task"},{"location":"Preparation/#sigel-etc","text":"from SIGEL.src.main.SIGEL import SIGEL ## get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) # key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image')","title":"SIGEL-ETC"},{"location":"Preparation/#sigel-svg","text":"## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"SIGEL-SVG"},{"location":"Preparation/#sigel-sc","text":"## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata)","title":"SIGEL-SC"},{"location":"SIGEL/","text":"Step1: Load data from SIGEL.src.main.SIGEL import SIGEL from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values Step2: Generate SGEs python ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step3: Hierarchical clustering ## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"SIGEL"},{"location":"SIGEL/#step1-load-data","text":"from SIGEL.src.main.SIGEL import SIGEL from sklearn.preprocessing import MinMaxScaler from scipy.cluster import hierarchy import seaborn as sns import matplotlib.pyplot as plt import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) gene_name = adata.var.index.values","title":"Step1: Load data"},{"location":"SIGEL/#step2-generate-sges","text":"python ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) SGEs = SGEs.detach().cpu().numpy() adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step2: Generate SGEs"},{"location":"SIGEL/#step3-hierarchical-clustering","text":"## select the gene family key_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37', 'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B', 'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1' ] combined_data = zip(gene_name, SGEs) emb = dict(combined_data) emb = {key:emb[key] for key, value in emb.items() if key in key_select} my_dict = {} for key in emb.keys(): my_dict[key] = np.array(emb[key]).flatten() sorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0]))) sorted_dict_value = np.array(list(sorted_dict.values())) scaler = MinMaxScaler() ## norm the data normalized_array = scaler.fit_transform(sorted_dict_value.T).T my_dict_norm = {} for i in range(len(sorted_dict)): key = list(sorted_dict.keys())[i] my_dict_norm[key] = normalized_array[i] ## plot hierarchical clustering results df = pd.DataFrame.from_dict(my_dict_norm, orient='index') sns.set(font_scale=2.5, font='sans-serif') row_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9 ## hierarchical clustering row_linkage = hierarchy.linkage(df, method='average') col_linkage = hierarchy.linkage(df.transpose(), method='average') # plot heatmap sns.set(font_scale=1., font='sans-serif' ) sns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8)) plt.show()","title":"Step3: Hierarchical clustering"},{"location":"SIGEL_ETC/","text":"Step1: Load 10x-mEmb and sqf-mEmb from SIGEL.src.SIGEL_ETC.src.main.SIGEL_ETC import SIGEL_ETC # get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image') Step2: Train the SIGEL-ETC # load pretrained SIGEL model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s] Step3: Generate genes expression image on the test set img_gen = SIGEL_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"SIGEL ETC"},{"location":"SIGEL_ETC/#step1-load-10x-memb-and-sqf-memb","text":"from SIGEL.src.SIGEL_ETC.src.main.SIGEL_ETC import SIGEL_ETC # get data on 10x and sqf adata = SIGEL_ETC.get_data(data='sqf', data_type='adata') adata, key_m, dataset_m = SIGEL_ETC.data_process(adata) #key_m, dataset_m = SIGEL_ETC.get_data(data='sqf', data_type='image') key_v, dataset_v = SIGEL_ETC.get_data(data='10x', data_type='image')","title":"Step1: Load 10x-mEmb and sqf-mEmb"},{"location":"SIGEL_ETC/#step2-train-the-sigel-etc","text":"# load pretrained SIGEL model = SIGEL_ETC.load_model() all_gmat_v2m, all_gmat_m2v = SIGEL_ETC.data_filter(key_v, dataset_v, key_m, dataset_m) Gen, SGEs = SIGEL_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46<00:00, 2.13it/s]","title":"Step2: Train the SIGEL-ETC"},{"location":"SIGEL_ETC/#step3-generate-genes-expression-image-on-the-test-set","text":"img_gen = SIGEL_ETC.sqf_gen(Gen, SGEs, adata) import matplotlib.pyplot as plt import torch import numpy as np fig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300) idx=329 key_m = np.array(list(all_gmat_m2v.keys())) # real visium img_real = torch.tensor(all_gmat_v2m[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 0].set_title(key_m[301]) axs[0, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[301]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[0, 1].set_title('real_{}'.format(key_m[301])) axs[0, 1].axis('off') # gen img img_fake = img_gen[301] axs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[0, 2].set_title('gen_{}'.format(key_m[301])) axs[0, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 0].set_title(key_m[308]) axs[1, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[308]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[1, 1].set_title('real_{}'.format(key_m[308])) axs[1, 1].axis('off') # gen img img_fake = img_gen[308] axs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[1, 2].set_title('gen_{}'.format(key_m[308])) axs[1, 2].axis('off') # real visium img_real = torch.tensor(all_gmat_v2m[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 0].set_title(key_m[324]) axs[2, 0].axis('off') # real img img_real = torch.tensor(all_gmat_m2v[key_m[324]]) img_real = img_real.squeeze(0) img_real = img_real.cpu().detach().numpy() axs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest') axs[2, 1].set_title('real_{}'.format(key_m[324])) axs[2, 1].axis('off') # gen img img_fake = img_gen[324] axs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest') axs[2, 2].set_title('gen_{}'.format(key_m[324])) axs[2, 2].axis('off') plt.show()","title":"Step3: Generate genes expression image on the test set"},{"location":"SIGEL_SC/","text":"SIGEL-SC Step1: Load data from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.SIGEL_SC.SIGEL_SC import SIGEL_SC from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s] Step2: Generate SVG score by SIGEL-SVG ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it] Stpe3: Carry out SIGEL-SC ## get original data adata= SIGEL.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SIGEL_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SIGEL_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only... Stpe4: Show the result ## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"SIGEL-SC"},{"location":"SIGEL_SC/#sigel-sc","text":"","title":"SIGEL-SC"},{"location":"SIGEL_SC/#step1-load-data","text":"from sklearn.metrics.cluster import normalized_mutual_info_score from collections import OrderedDict from sklearn.metrics import adjusted_rand_score from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.SIGEL_SC.SIGEL_SC import SIGEL_SC from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27<00:00, 56.85gene/s]","title":"Step1: Load data"},{"location":"SIGEL_SC/#step2-generate-svg-score-by-sigel-svg","text":"## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12<00:00, 14.41s/it] ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27<00:00, 14.76s/it]","title":"Step2: Generate SVG score by SIGEL-SVG"},{"location":"SIGEL_SC/#stpe3-carry-out-sigel-sc","text":"## get original data adata= SIGEL.get_data(sample_id='151676', data_type='adata') ## select genes new_samples_indices = SIGEL_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5) select 9263 genes ## spatial clustering adata = SIGEL_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7) Calculateing adj matrix using xy only... Run 1: l [0.01, 1000], p [0.0, 3421.9987256815807] Run 2: l [0.01, 500.005], p [0.0, 3416.00732421875] Run 3: l [0.01, 250.0075], p [0.0, 3392.22265625] Run 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625] Run 5: l [0.01, 62.509375], p [0.0, 2971.17138671875] Run 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625] Run 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938] Run 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844] Run 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922] Run 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445] Run 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857] Run 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291] Run 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291] Run 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291] Run 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291] Run 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291] recommended l = 0.48301773071289056 Start at res = 0.7 step = 0.1 Initializing cluster centers with louvain, resolution = 0.7 2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`. Epoch 0 Epoch 10 Res = 0.7 Num of clusters = 7 recommended res = 0.7 Initializing cluster centers with louvain, resolution = 0.7 Epoch 0 Epoch 10 Epoch 20 Epoch 30 Epoch 40 Epoch 50 Epoch 60 Epoch 70 Epoch 80 Epoch 90 Epoch 100 Epoch 110 Epoch 120 Epoch 130 Epoch 140 Epoch 150 Epoch 160 Epoch 170 Epoch 180 Epoch 190 Calculateing adj matrix using xy only...","title":"Stpe3: Carry out SIGEL-SC"},{"location":"SIGEL_SC/#stpe4-show-the-result","text":"## get ground truth adata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] ## caculate ARI and NMI label_pred = list(adata.obs['r_pred']) label_pred = np.array(label_pred).astype(int) ground_truth = list(adata.obs['Ground Truth']) category_to_int = {category: idx for idx, category in enumerate(set(ground_truth))} i = 0 for key in category_to_int: category_to_int[key] = i i = i+1 ground = [category_to_int[category] for category in ground_truth] ari = adjusted_rand_score(ground, label_pred) print(\"ARI:\", ari) nmi = normalized_mutual_info_score(ground, label_pred) print(\"NMI:\", nmi) ARI: 0.5170212162200523 NMI: 0.6375916808656412 ## plot ground truth domains=\"Ground Truth\" plot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"] num_celltype=len(adata.obs[domains].unique()) adata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype]) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b ## adjust the color according to the Hungarian algorithm y_true = np.array(ground) y_pred = np.array(adata.obs['r_pred']) y_true = y_true.astype(np.int64) assert y_pred.size == y_true.size D = max(y_pred.max(), y_true.max()) + 1 w = np.zeros((D, D), dtype=np.int64) for i in range(y_pred.size): w[y_pred[i], y_true[i]] += 1 from scipy.optimize import linear_sum_assignment as linear_assignment ind = (np.array(linear_assignment(w.max() - w))).transpose() adata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]] ## plot pred map domains=\"r_pred\" num_celltype=len(adata.obs[domains].unique()) ax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0]) ax.set_aspect('equal', 'box') ax.axes.invert_yaxis() plt.show() \u200b \u200b","title":"Stpe4: Show the result"},{"location":"SIGEL_SVG/","text":"Step1: Load data from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s] Step2: Train SIGEL to get SGEs ## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it] Step3: Generate SVG score ## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it] Step4: Display the result ## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"SIGEL SVG"},{"location":"SIGEL_SVG/#step1-load-data","text":"from SIGEL.src.SIGEL_SVG.utils import simu_zinb from SIGEL.src.SIGEL_SVG.utils import get_svg_score from SIGEL.src.main.SIGEL import SIGEL import matplotlib.pyplot as plt import pandas as pd import scanpy as sc import numpy as np import warnings warnings.filterwarnings(\"ignore\") ## get adata and image data adata= SIGEL.get_data(sample_id='151676', data_type='adata') dataset, adata = SIGEL.data_process(adata) adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25<00:00, 57.27gene/s]","title":"Step1: Load data"},{"location":"SIGEL_SVG/#step2-train-sigel-to-get-sges","text":"## train model with pretrained model y_pred, SGEs, model = SIGEL.train(dataset=dataset, pretrain=False) use cuda: True load pretrained mae from SIGEL/model_pretrained/SIGEL.pkl Clustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55<00:00, 15.84s/it]","title":"Step2: Train SIGEL to get SGEs"},{"location":"SIGEL_SVG/#step3-generate-svg-score","text":"## generate SVG score adata.X = adata.X.todense() svg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10) 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29<00:00, 14.93s/it]","title":"Step3: Generate SVG score"},{"location":"SIGEL_SVG/#step4-display-the-result","text":"## obtain spatial variable gene index ascending_indices = np.argsort(svg_score) descending_indices = ascending_indices[::-1] ## get gene name from adata gene_name = adata.var.index.values ## gene expression whitin high svg score plot_gene = gene_name[descending_indices[:4]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show() ## gene expression whitin low svg score plot_gene = gene_name[ascending_indices[2:6]] fig, axs = plt.subplots(2, 2, figsize=(8, 8)) sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99') sc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99') plt.tight_layout() plt.show()","title":"Step4: Display the result"}]}